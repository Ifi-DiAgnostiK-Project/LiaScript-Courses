name: Generate LiaScript Outputs for Changed Courses

# This workflow uses a TWO-PHASE approach to ensure version increments and tag creation stay synchronized:
#
# PHASE 1 (triggered by user commit):
#   - Detect if version needs incrementing
#   - If yes: commit version increment WITHOUT [skip ci] and stop
#   - This triggers PHASE 2
#
# PHASE 2 (triggered by version-increment commit):
#   - Detect this is a version-increment commit (by checking commit message)
#   - Skip version increment step
#   - Continue to create releases and tags with the updated version
#
# This design ensures that if the workflow crashes after version increment,
# it can be re-run without manual intervention, keeping versions and tags in sync.

on:
  push:
    branches:
      - main
    paths:
      - 'courses/**.md'
  pull_request:
    branches:
      - main
    paths:
      - 'courses/**.md'
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Prevent concurrent runs that modify repository state
# This ensures workflows triggered by course changes don't race with each other
concurrency:
  group: course-modifications
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  check_changes:
    runs-on: ubuntu-latest
    outputs:
      changed_files: ${{ steps.changes.outputs.changed_files }}
      # version_incremented values:
      #   'true' = Phase 1, version was just incremented and pushed
      #   'false' = version_check ran but no increment was needed
      #   unset/empty = version_check step was skipped (Phase 2: version-increment commit)
      version_incremented: ${{ steps.version_check.outputs.version_incremented }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          path: project
          fetch-depth: 2
          # Use custom token to allow triggering workflows on push
          token: ${{ secrets.PUSH_INDEX_2 }}

      - name: Check if this is a version-increment commit
        id: check_commit
        run: |
          cd project
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -q "Auto-increment version tags"; then
            echo "is_version_commit=true" >> $GITHUB_OUTPUT
            echo "This is a version-increment commit, skipping version increment step"
          else
            echo "is_version_commit=false" >> $GITHUB_OUTPUT
            echo "This is a regular commit, will check for version increment"
          fi

      - name: Show recent git history for debugging
        run: |
          cd project
          git log --oneline --graph --all | head -20

      - name: Set up Python for version check
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      
      - name: Show checksum state if exists
        run: |
          cd project
          if [ -f .checksum_state.json ]; then
            echo "Previous checksum state found in repository:"
            ls -lh .checksum_state.json
            git log -1 --format="%h %s" .checksum_state.json || echo "No commit history for checksum state"
          else
            echo "No previous checksum state found (first run)"
          fi

      - name: Check and auto-increment version tags
        id: version_check
        # Only check versions if this is NOT already a version-increment commit
        # This prevents infinite loops: version commits don't trigger another version increment
        if: steps.check_commit.outputs.is_version_commit != 'true'
        run: |
          cd project
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          python3 scripts/check_and_increment_version.py
          # Commit any version changes WITHOUT [skip ci] to allow workflow to continue
          if ! git diff --quiet; then
            # Pull latest changes to avoid conflicts with concurrent workflows
            git pull --rebase origin main || {
              echo "Failed to pull latest changes, attempting to continue anyway"
            }
            git add -u courses/
            git commit -m "Auto-increment version tags for changed courses"
            git push
            echo "version_incremented=true" >> $GITHUB_OUTPUT
            echo "✓ Version incremented and pushed. Workflow will be re-triggered to create releases."
          else
            echo "version_incremented=false" >> $GITHUB_OUTPUT
            echo "✓ No version increment needed."
          fi

      - name: Detect Changed Markdown Files
        id: changes
        # Run in two cases:
        # 1. This IS a version-increment commit (Phase 2: create releases)
        # 2. No version was just incremented (normal flow or manual version change)
        # Skip if version was just incremented (Phase 1: wait for Phase 2)
        if: |
          steps.check_commit.outputs.is_version_commit == 'true' || steps.version_check.outputs.version_incremented != 'true'
        run: |
          cd project
          files=$(git diff --name-only HEAD^  HEAD | grep '^courses/.*\.md$' || true)
          echo "changed_files=${files//$'\n'/ }" >> $GITHUB_OUTPUT
          echo "Changed files: ${files//$'\n'/ }"
      
      - name: Update and commit checksum state
        if: steps.changes.outcome == 'success'
        run: |
          cd project
          # Update the checksum state
          python3 scripts/checksum_state.py update
          echo "Checksum state updated"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Commit the state file if it changed
          if ! git diff --quiet .checksum_state.json; then
            # Pull latest changes to avoid conflicts with concurrent workflows
            git pull --rebase origin main || {
              echo "Failed to pull latest changes, attempting to continue anyway"
            }
            git add .checksum_state.json
            git commit -m "Update checksum state [skip ci]"
            
            # Push changes - fail if this doesn't work to prevent state desync
            if ! git push; then
              echo "❌ ERROR: Failed to push checksum state" >&2
              echo "This is critical - without updated state, the next run will be incorrect" >&2
              echo "Common causes: concurrent workflow runs, network issues, or permission problems" >&2
              echo "Recovery: Re-run this workflow after resolving the issue" >&2
              exit 1
            fi
            echo "✓ Checksum state committed and pushed"
          else
            echo "✓ Checksum state unchanged, no commit needed"
          fi

  generate_outputs:
    runs-on: ubuntu-latest
    needs: check_changes

    steps:
      - name: Get changed files from previous job
        id: read_changes
        run: |
          CHANGED="${{ needs.check_changes.outputs.changed_files }}"
          echo "changed_files=${CHANGED}" >> $GITHUB_OUTPUT
          if [ -n "$CHANGED" ]; then
            echo "Will process changed files: $CHANGED"
          else
            echo "No changed files to process"
          fi

      - name: Checkout Repository
        uses: actions/checkout@v4
        if: steps.read_changes.outputs.changed_files != ''
        with:
          path: project
          fetch-depth: 2

      - name: Pull latest changes (including version commit)
        if: steps.read_changes.outputs.changed_files != ''
        run: |
          cd project
          git pull --ff-only origin ${{ github.ref_name }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        if: steps.read_changes.outputs.changed_files != ''
        with:
          node-version: '22'

      - name: Install LiaScript Exporter
        if: steps.read_changes.outputs.changed_files != ''
        run: |
          npm install -g @liascript/exporter

      - name: Export & Release for Each Changed File
        if: steps.read_changes.outputs.changed_files != ''
        run: |
          set -euo pipefail
          mkdir -p build
          cd project
          for file in ${{ steps.read_changes.outputs.changed_files }}; do
            filename=$(basename "$file" .md)
            safe_tag=$(echo "$filename" \
              | tr '/' '_' \
              | tr '[:upper:]' '[:lower:]' \
              | sed -e 's/ä/ae/g' -e 's/ö/oe/g' -e 's/ü/ue/g' -e 's/ß/ss/g' \
                    -e 's/Ä/ae/g' -e 's/Ö/oe/g' -e 's/Ü/ue/g' \
                    -e 's/[^a-z0-9_-]//g')

            # Extract version from file
            version=$(grep -oP 'version:\s*\K[\d.]+' "$file" || echo "unknown")

            # Export assets
            liaex -i "$file" --format pdf --output "../build/${filename}_v${version}_Documentation" --pdf-timeout 50000
            liaex -i "$file" --format scorm2004 --output "../build/${filename}_v${version}_SCORM"

            # Create release per file
            gh release create "${safe_tag}_v${version}" \
              --title "Export for $filename (v${version})" \
              "../build/${filename}_v${version}_Documentation.pdf" \
              "../build/${filename}_v${version}_SCORM.zip" \
              --notes "Automated export for $file - version ${version}"

          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  create_project_index_html:
    runs-on: ubuntu-latest
    needs: [check_changes, generate_outputs]
    # Skip when version was just incremented in Phase 1 (version_incremented == 'true')
    # Run in Phase 2 (version_incremented unset/empty) or when no increment needed (version_incremented == 'false')
    # Note: Unset outputs are treated as empty strings in GitHub Actions, so != 'true' matches both unset and 'false'
    if: needs.check_changes.outputs.version_incremented != 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Pull latest changes (including version commit)
        run: |
          git pull --ff-only origin ${{ github.ref_name }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '22'

      - name: Install LiaScript Exporter
        run: |
          npm install -g @liascript/exporter

      - name: Generate project.yml
        run: |
          python generate_project_yaml.py

      - name: Debug output
        run: |
          echo "Generated project.yml:"
          cat project.yml

      - name: Generate index.html from project.yml
        run: |
          set -euo pipefail

          TARGET="docs/index.html"

          # Compute pre-hash (empty if not present)
          if [ -f "$TARGET" ]; then
            PRE_HASH=$(sha256sum "$TARGET" | awk '{print $1}')
          else
            PRE_HASH="__MISSING__"
          fi
          echo "pre-hash: $PRE_HASH"
          
          # generator
          liaex -i project.yml --format project --project-generate-cache --output docs/index

          # Compute post-hash (empty if not present)
          if [ -f "$TARGET" ]; then
            POST_HASH=$(sha256sum "$TARGET" | awk '{print $1}')
          else
            POST_HASH="__MISSING__"
          fi
          echo "post-hash: $POST_HASH"

          if [ "$PRE_HASH" = "$POST_HASH" ]; then
            echo "No change detected in $TARGET — failing step as requested."
            exit 1
          fi

          echo "$TARGET changed (proceeding)."


      - name: configure Python and beautifulSoup
        run: |
          sudo apt-get update
          sudo apt-get install python3-pip -y
          pip3 install beautifulsoup4 lxml

      - name: modify index.html to include releases
        run: |
          set -euo pipefail
          # Use BeautifulSoup to modify the index.html
          python3 add_release_to_index.py

      - name: WORKAROUND for Cards with more then one category
        run: |
          set -euo pipefail
          # WORKAROUND: Untertapeten Card needs to be in two categories
          # FIXME: Remove when LiaScriptExporter supports multiple categories per course
          echo "WORKAROUND: Copy Card to duplicate certain cards into another category"
          python3 clone_cards.py docs/index.html

      # if index didn't change, we don't need to commit; this happens naturally if no courses were changed
      - name: Commit index.html to docs/
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Pull latest changes to avoid conflicts with concurrent workflows
          git pull --rebase origin main || {
            echo "Failed to pull latest changes, attempting to continue anyway"
          }
          
          git add docs/index.html
          git commit -m "Update index.html from project.yaml"|| echo "No changes to commit"
        env:
          # Required for authentication
          GITHUB_TOKEN: ${{ secrets.PUSH_INDEX_2 }}
      - name: Push changes
        uses: ad-m/github-push-action@v0.8.0
        with:
          github_token: ${{ secrets.PUSH_INDEX_2}}
          branch: main
          directory: ./docs

  update_course_count:
    runs-on: ubuntu-latest
    needs: [check_changes]
    # Skip when version was just incremented in Phase 1 (version_incremented == 'true')
    # Run in Phase 2 (version_incremented unset/empty) or when no increment needed (version_incremented == 'false')
    if: needs.check_changes.outputs.version_incremented != 'true'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Count Course Files
        id: count_courses
        run: |
          course_count=$(find courses/ -name "*.md" -type f | wc -l)
          # Ensure course_count is numeric
          if ! [[ "$course_count" =~ ^[0-9]+$ ]]; then
            echo "Error: Invalid course count, defaulting to 0"
            course_count=0
          fi
          echo "Course count: $course_count"
          echo "count=$course_count" >> $GITHUB_OUTPUT

      - name: Read Existing Badge Data
        id: read_badge
        run: |
          if [ -f .badges/course-count.json ]; then
            previous_count=$(jq -r '.message // "0"' .badges/course-count.json 2>/dev/null || echo "0")
            # Ensure previous_count is numeric
            if ! [[ "$previous_count" =~ ^[0-9]+$ ]]; then
              previous_count=0
            fi
            echo "Previous count: $previous_count"
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "previous_count=$previous_count" >> $GITHUB_OUTPUT
          else
            echo "Badge file does not exist"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "previous_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Check if Update Needed
        id: check_update
        run: |
          current_count="${{ steps.count_courses.outputs.count }}"
          previous_count="${{ steps.read_badge.outputs.previous_count }}"
          badge_exists="${{ steps.read_badge.outputs.exists }}"
          
          if [ "$badge_exists" = "false" ]; then
            echo "Update needed: Badge file does not exist"
            echo "needs_update=true" >> $GITHUB_OUTPUT
          elif [ "${current_count:-0}" -ne "${previous_count:-0}" ]; then
            echo "Update needed: Count changed from $previous_count to $current_count"
            echo "needs_update=true" >> $GITHUB_OUTPUT
          else
            echo "No update needed: Count unchanged at $current_count"
            echo "needs_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Create Badge JSON
        if: steps.check_update.outputs.needs_update == 'true'
        run: |
          mkdir -p .badges
          cat > .badges/course-count.json << EOF
          {
            "schemaVersion": 1,
            "label": "courses",
            "message": "${{ steps.count_courses.outputs.count }}",
            "color": "brightgreen"
          }
          EOF
          cat .badges/course-count.json

      - name: Commit Badge Data
        if: steps.check_update.outputs.needs_update == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Pull latest changes before pushing (e.g., from index.html job or manual commits)
          # Use --rebase --autostash to apply our badge update on top of any new commits;
          # --autostash stashes the badge file written in the previous step so the rebase
          # can succeed even though there are uncommitted changes.
          git pull --rebase --autostash origin main || {
            echo "Failed to pull latest changes, attempting to continue anyway"
          }
          
          git add .badges/course-count.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Update course count badge data [skip ci]"
            git push
          fi
